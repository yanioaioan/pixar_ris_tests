#RIB RIB
# RIB Generated by Houdini
version 3.03


Option "statistics" "int endofframe" 1 "string xmlfilename" "disp.xml"

#Display "disp.tif" "tiff" "rgba"
Quantize "rgba" 255 0 255 0
Format 720 576 1
Projection "perspective" "fov" [45]

PixelVariance 0
Hider "raytrace" "int incremental" [1] "int maxsamples" [4]

#Integrator "PxrDefault" "integrator"
Integrator "PxrPathTracer" "handle" "int numLightSamples" [8] "int numBxdfSamples" [8] "int numIndirectSamples" [4] "int numDiffuseSamples" [4] "int numSpecularSamples" [4]


#Integrator "PxrDirectLighting" "integrator"
#Integrator "PxrVCM" "integrator"



# Use this integrator to see the normals of the displaced surface
#Integrator "PxrDebugShadingContext" "dsc" "string viewchannel" ["Nn"]



FrameBegin 1	# {
 Display "lemon" "framebuffer" "rgba" 
 #Display "lemon.tiff" "file" "rgba" 
 Format 720 576 1
 Exposure 1 1.8
 
 ShadingRate 1
 ScreenWindow -1 1 -0.759375 0.759375
 Projection "perspective" "fov" [45]
 Clipping 0.001 1000
 Transform [0.999632 0.00343098 0.0268948 0 0.0127459 0.816045 -0.577848 0
	0.0239299 -0.577978 -0.815701 0 -0.172875 2.10146 19.1487 1]
 WorldBegin	# {
 Attribute "visibility" "trace" [ 1 ]
  Atmosphere "depthcue"
		"background" [ 0 0 1 ]
		"mindistance" [0.015]
		"maxdistance" [0.025]
 TransformBegin
 CoordinateSystem "worldspace"
 TransformEnd
  #
  # Light: light3
  Transform [1 0 0 0	 0 1 0 0	 0 0 -1 0 	0 2 0 1]

	#AreaLightSource "PxrStdAreaLight" "theLight" "float exposure" [4]
	
  #PROPER LIGHTS NEEDED TO BE DEFINED, otherwise all Integrators apart from the Default/Debug won't work
  AttributeBegin
    Attribute "visibility" "int transmission" 0 "int camera" 0
    Attribute "trace" "bias" 0.001
    ShadingRate 1000
    Sides 1
    Rotate 65 0 1 0
    Translate 0 60 0
    AreaLightSource "PxrAreaLight" "light0" "color lightcolor" [1 0.9 0.8] "float intensity" 8 
    TransformBegin
      Translate 0 0 -75
      Scale 70 70 70
      Geometry "rectlight"
    TransformEnd
    AreaLightSource "PxrAreaLight" "light1" "color lightcolor" [0.9 0.9 1] "float intensity" 6
    TransformBegin
      Translate 0 0 150
      Rotate 180 1 0 0
      Scale 70 70 70
      Geometry "rectlight"
    TransformEnd
  AttributeEnd
	
CoordinateSystem "myOrigin"
    Transform [1 0 0 0 0 1 0 0
	0 0 1 0 0 -0.5 0 1]

	
#float voronoi ( vector v, int type = 1, float jitter = 0.5, float fbmScale = 0, int fbmOctaves = 4, float fbmLacunarity = 2, float fbmGain = 0.5)
Pattern "PxrSeExpr" "height" "string expression"
["\
$val=voronoi(25*[$u,$v,0],0, 0.5 ,0, 4, 2, 0.5); \
$val = $val* $val * $val  ;\
$val\
"]



AttributeBegin
#Attribute "identifier" "name" ["sphere1"]

#now search for any displacements happened as part of the 'displacement' method displacement shader
Attribute "trace" "int displacements" 1
Attribute "displacementbound" "sphere" 2 "coordinatesystem" "world"


#Displace using displacement shader
Surface "lemonDisplacementShader" "reference float disp" ["height:resultF"] "float disp" [1.1] "float atten" [1]
#Bump based on lemon texture
#Pattern PxrBump "myLemonBump" "string filename" "lemon.tx"
#Bxdf "PxrDisney" "LemonBump" "reference color baseColor" ["myLemonBump:resultN"]

#Load the bumpy.osl shader (after having compiled it to slo with the oslc command)
Pattern "PxrOSL" "myOSLShaderContribution" "string shader" "simplesurface" "color Cin" [0.8 0.5 0]

#Apply lemon .tx Texture as the base color
Pattern "PxrTexture" "myLemonTexture" "string filename" "lemon.tx"
Bxdf "PxrDisney" "lemonTexture" "reference color baseColor" ["myLemonTexture:resultRGB"] "float roughness" [0.2]  "reference color subsurfaceColor" ["myOSLShaderContribution:Cout"] "float subsurface" [0.2]

#Bxdf "PxrDisney" "smooth" "color baseColor"  [0.8 0.7 0.05]

Translate -1 6 12

Sphere 2 -2 2 360
#Cylinder .5 .2 1 360



Translate 2 0 0
#Sphere 2 -2 2 360
  

AttributeEnd
  
 WorldEnd	# }
FrameEnd	# }
